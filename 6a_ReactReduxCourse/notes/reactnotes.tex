\documentclass[8pt,a4paper]{extarticle}
%\documentclass[8pt,twocolumn,a4paper]{extarticle}
%\documentclass[6pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{setspace} 
\usepackage{float}
\usepackage{url}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{multicol}

\pagecolor{black}
\setlist{nolistsep}
\topmargin -2cm
\oddsidemargin -1.5cm
\evensidemargin -1.5cm
\textwidth 18.75cm
\textheight 26cm
\linespread{1.00}
\color{YellowOrange}

%Other Colors: ForestGreen,Cerulean,Salmon,Purple, Red, White

\twocolumn
\title{Title Here}
\author{Author Name Here}

\begin{document}

\newcommand{\mitem}{\item[$\square$]}
\newcommand{\mmitem}{\item[$\triangledown$]}

\maketitle


\section*{First React Application:}

\begin{itemize}
\item To start a React Project, most developers will utilize the create-react-app project template (a node package). Simply install this package and run it to start.
Specifically:

\begin{verbatim}

npx create-react-app <project name>
mkdir <project name>
npm start

\end{verbatim}

to install and get the local server running.

\item \textbf{Project Structure:}
\item \textbf{./nodemodules:} All locally installed node dependences are stored here.
\item \textbf{./public:} index.html (front page, robots.txt and favicons stored here.
\item \textbf{./src:} Contains the React Apps (self-contained pieces of interface+code), and support files, including:

- App.js (contains template React App)
- .test files (to run tests later)
- index.js: Where we Insert our App DOM object into the index.html DOM tree (at root).

\item The following minimial code is needed to insert our content into the index.html DOM tree:

\begin{verbatim}
import React from 'react';
import ReactDOM from "react-dom";
ReactDOM.render(<div>Our React Element </div>, 
document.getElementById("root"));
\end{verbatim}

\item In react, we typically bundle reusable UI elements into \textbf{Components}. 
\item \textbf{Components:} reusable pieces of React code to control part of the user interface. Components capture the structure of UI, and can have internal data to track the user behavior throughout the lifetime of the app.

\item A react app will contain many different \textbf{Components}.
\item Naturally, react has a Component class that can be imported from the react core library.

\begin{verbatim}
import { Component } from 'react';
\end{verbatim}

\item Note that Classes, extended Sub-Classes and object Instances are used heavily in React - so be familiar with OOP.
\item A typical design pattern in React will be to extend template component classes, and add additional fields/methods to implement your application.
\item If you write javascript in the App.js and index.js - console.log() will output directly to a browser inspector.
\item React automatically detects saved changes, and the local server updates. So you can update accordingly.
\item \textbf{State Field:} Subclasses of the Components class have a state field that we can use. We can link an object to this field, to maintain current state as the Component runs.
\item \textbf{State:} dynamic data in a React component. This is often used to track variables that will be re-rendered in the UI based on events that occur in the application.
\item \textbf{React Rule:} \textbf{Never} Directly Modify the State property, if your intention is for changes to occur in the render method based on the updated state values. Use \textit{setState()} instead.
\item \textbf{But Why??} React is \textit{designed to re-render()} a given component when the setState() function is called. If you modify state directly, the changes will \textbf{not} be reflected in browser.
\item \textbf{Props:} Just stands for "Property". Data in a React component that gets passed down from its parent. In the parent component, it will pass data down to the child component through attributes in the child component’s JSX.
\item Practically, how does the passing work? See the example below:

\begin{verbatim}
class Profile extends Component {
 const {img, link} = this.props.profile

...

}

class SocialProfiles extends Component {
render() {
...
SOCIALPROFILES.map( prof => {
return )
<Profile key={prof.id} profile={prof />
...

}
}
\end{verbatim}

Note that the SOCIALPROFILEs data object gives us our data for this example. We map() on each element of the object.

Here, our Profile class defines a component that is a child to the SocialProfiles Class. We instantiate an object of the Profile class using the $<$Profile tag$>$. In the tag, we have placed properties (id, profile) that are fed into the object instance of Profile. We then can access these properties with \textit{this.props(.profile...)}
\item Visual Summary, \textbf{our modified \textit{create-react-app} project:}

\includegraphics[scale=0.27]{appstructure.png}

\end{itemize}



\section*{Breaking Down React: React and Web Development:}

\begin{itemize}
\item For this section, we will not use the template \textit{create-react-app}, and build a bottom up example.
\item Instead, we will use transpilation and packaging, with a minimal setup, to produce a basic React application.
\item In the end, much of the structure in \textbf{create-react-app} is not necessary to get a minimal example to run.
\item All an app needs is one index.html page, and index.js page.
\item You don't even need to run "npm start" or "node react" - you can use CDNs to load React and ReactDOM libriaries straight into the browser.
\item \textbf{The Minimal Example is as follows:}
\mitem React CDN script tags at the end of index.html
\mitem A div root tag in index.html, so React can insert our $<$App$>$ into the DOM tree.

In index.js you can just build an app, render() and insert it as normal.
\item \textbf{JSX:} This is syntactic sugar that is transpiled to code that the browser will understand, when we run our react project (with npm start).
\item Transpilation is typically done with the \textbf{Babel package}.
\item \textbf{Why use Babel?} Javascript compliance is entirely Browser dependent - and JS core language development is completely separate from Browser development. When we want new features that Browsers may not yet support - we can transpile code to cruder JS so that it can be used in current browsers.

\item \textbf{Bundling and Transpiling:} Note that our React project will run in the browser, but ultimately Chrome/FF will not support our import/export system, nor will it support JSX. So we use a \textbf{bundler package (Parcel)} that utilizes Babel to produce a low-level enough JS file so that Chrome/FF can run our app. 
\item Parcel traces our application code, and finds all possible dependences, and then places all imported code into one mega-js file. Any syntactic sugar (such as JSX) is transpiled into lower level JS code that a browsre can understand.

\includegraphics[scale=0.24]{bundle.png}

\item \textbf{Why Use Parcel?} The alternative is to import multiple scripts into the index.html page. These are loaded in order. As our project incrases in size+complexity we may deal with loading issues (namespace clobbering, circular dependencies, etc). To avoid this, Parcel will make one large JS file where dependency/NS issues are alleviated.

\item \textbf{Basic Parcel Usage:}

\begin{verbatim}
parcel <index.html>
\end{verbatim}

It will trace back all code depedencies from here.
 
\item Parcel Folders (in project): These will appear after you run parcel the first time:
\mitem \textbf{.cache}: Stores compiled elements to minimize recompilation later.
\mitem \textbf{dist:} Folder where bundled+transpiled JS code is stored - will rewrite index.html script links to point to this directory!
\item Using Parcel for Dev and Production: Parcel has a hot-wire feature - we can run it with the index.html, and it will auto-update all our code as we develop it.

Parcel however is heavier-weight - we don't use it when we launch produciton code. The following package.json scripts would be seen for a parcel build:

\begin{verbatim}
"scripts": {
    "dev": "parcel src/index.html",
    "build": "parcel build src/index.html",
    "start": "npm run build && live-server dist"
  }
\end{verbatim}

A lighter server (live-server) is chosen to strip down the size of the compiled production build, for launch.

\item \textbf{VirtualDOM:} React has its own stripped-down DOM model, so that it can make dynamic changes to the application page. Note: You don't use native DOM methods (like createElement, getElementById()...) in React - it has its own framework calls to do manipuations.
\end{itemize}

\section*{Continued Main React Concepts:}

\begin{itemize}
\item \textbf{Component Lifecycle:} Components have various event methods, that can be triggered during there operation. In particular, we are interested in when the component starts up, and when it shuts down with two methods:
\item \textbf{componentDidMount():} Called after component is loaded. If the method has to perform setup work or a fetch(), write this code in here.
\item \textbf{ComponentWillUnmount():} Called just before a Component is unmounted and destroyed. Use this as a takedown/cleanup/signalling method.
\item Both methods above are written in the Component extended class - use non-first class functions only. "function" keyword is not required (its a JS class!).
\item \textbf{Stateless Functional Components:} Simplified Notation can be used, if our components contain no state. See Example Below:

\begin{verbatim}

const Project = props => {
	//destructure
  const { title, image, description, link } = props.project;
 
  return (
    <div style={{}}>
      <h3> {title} </h3>
      <img src={image} alt='profile' />
      <p>{description}</p>
      <a href={link}>{link}</a>
    </div>
  )
}
\end{verbatim}

Notice that for static/one-time components, we don't even need the render() method. We can even skip the return and encase the functional body with () - however we did destructuring above, so in this case it cannot be made that simple. Most simple example below:

\begin{verbatim}
const SimpleComp = props => {
	<div>   ~~SOME JSX~~   </div>
}
\end{verbatim}


\item \textbf{fetch():} Default Node/React method for making HTTP calls to external sources. When apps communicate by APIs, HTTP+fetch is typically how it is done.
\item fetch() returns a JS Promise - and is an asyncronous function.
\item \textbf{Fetch Example 1:} Get a JSON object and print it:
\begin{verbatim}
fetch("http://localhost:3005/random_joke")
    .then(response => console.log(response.json()))
    .catch(error => console.log("Error:", error.message));
\end{verbatim}

Will print out json object to console. Basic errors also handled.

\item Example 2: Extract an array of JSON objects from promise, and work with them:

\begin{verbatim}
...
  state = {...jokes: []};

  fetchJokes = () => {
    //Same remainder code, regardless
    fetch("http://localhost:3005/random_ten")
    .then(response => response.json())
    .then(json => this.setState({jokes:json}))

...

 { //At site where we want to print objects...
   this.state.jokes.map(joke => (
   <Joke key={joke.id} joke={joke}/>
    ))
 }
\end{verbatim}

We use the state and setState to pull the jokes array. We can then work on it, avoiding promise/fucntional notation later on down the in the code.

\item \textbf{NOTE (!)} I could not get routing or higher-order functions to work (!!) - course code versions are too old.
\item Applying routing to the application. With react-router, a single page React application can transform into one with multiple pages of different content. Each page matches a url path of the application to a different component.
\item \textbf{Higher-order Components:} A higher-order component is one that takes another component as an input. The idea is to treat the component like a function. Have one component as input, and then output an entirely new component based on that input, with new properties, methods, and/or JSX!
\item
\end{itemize}

\section*{Music Master 2.0}

\begin{itemize}
\item API service was not available for this project, I just found my own data source instead and did my best. Some useful coding patterns/concepts are below:

\item \textbf{Arrow callbacks - Returning the Callback itself} (instead of return() value):

\begin{verbatim}
myfunction => props => () => { return(...)}
\end{verbatim}

This will return the inner function, with access to the outer parameters. In other words, equivalent to:

\begin{verbatim}
function (props) {
	return function() { body... }
}
\end{verbatim}
\item
\end{itemize}

\section{Redux and more Advanced React:}

\begin{itemize}
\item Redux is a State Management technology.
\item It handles all the underlying data for your React application by enforcing a universal flow of data - that components can read from and add to using dispatchable actions.
\item It passes state/data between different components in our Application. 
\item Parent $\rightarrow$ Child data-passing can be prohibitive in complex situations - so we use Redux for a cleaner solution.
\item \textbf{Main Parts of Redux:}
\item 1) \textbf{(Global) Store:} Collects the state of the entire application.
\item 2) \textbf{Reduces:} Reducers split up the store and describe how sections of the store should update.
\item \textbf{Actions:} Objects (emitted events) full of data, processed by Reducers.
\item 4) \textbf{Dispatchers:} Components that create action objects.
\item This model creates a \textbf{Unidirectional Flow} of data.

\includegraphics[scale=0.25]{redux_chart.png}

\item Actions are objects full of data that the reducers listen to. These actions are dispatchable by components. And reducers will then use the action data to update the redux store.
\item All reducers listen for actions (events that contain data). Each one fires, and checks the type of the action - to see if it handles it.
\item It is the responsibility of the programmer to check/filter types correctly in each reducer.
\item Actions are typed objects: they must contain a \textbf{type} field - this is how reducers filter them. An example of an action:

\begin{verbatim}

export const startGame = () => {
  return {type:SET_GAME_STARTED, gameStarted:true};
}

\end{verbatim}

\item Redux and React are two separate frameworks - they must be integrated together in a project. This specifically means: 
\item React Redux provides the connection between the redux system and the React components. Particularly, the Provider component gives each component access to the redux store. And the connect function allows each component to customize what parts of the redux store it wants to read, and what actions the component should be able to dispatch.
\item 1) Components in React act as dispatchers for actions (Redux)
\item Components in React will query the Redux Global Store, to interpret application state.
\item \textbf{Redux Structuring:} The following folders and files are used, for each of the key objects in Redux:
\item 1) Actions: Stored in an $./src/actions$ folder. \\

There is a settings.js file where all arrow function actions are stored, and exported.\\

There is a types.js file, which lists all of our action types and exports them (so Reducers can use the types). An example of a type constant:

\begin{verbatim}

export const SET_GAME_STARTED = "SET_GAME_STARTED";

\end{verbatim}

\item 2) Reducers: Placed in the $./src/reducers$ folder, in a file called index.js. These are exported as well. An example of a reducer:

\begin{verbatim}

const rootReducer = (state = DEFAULT_SETTINGS, action) => {
 
  switch(action.type) { 
    case SET_GAME_STARTED:
      return {
        gameStarted:action.gameStarted,
        instructExp:state.instruct
      }; 
    case SET_INSTRUCTIONS_EXPANDED:       
    return { ...state, instructExp:action.instructExp };
    default:
      return state;
  }
}

\end{verbatim}

\item 3) Dispatching Setup: This is typically done in App.js. See the following code:

\begin{verbatim}
import React, { Component } from 'react';
import { connect } form 'react-redux';

class App extends Component {
  render() {
    return (
      <div>React App</div>
    );
  }
}

const componentConnector = connect();

export default App;
\end{verbatim}

The connect() function connects the App component to Redux, so it can be used as a dispatcher.

\item \textbf{MapStateToProps}: parameter one of the react-redux connect function customizes which part of the redux store the component will have access to.

\item \textbf{MapDispatchToProps}: parameter two of the react-redux connect function specifies which action creators the component should be able to dispatch.


\item 4) Setting up the Provider Frame: Note that to use global state, we must wrap our App in another structure called a Provider. We do this in the project index.js file:

\begin{verbatim}
import React from 'react';
import ReactDOM from 'react-dom';
import App from './components/App';
import { createStore } from 'redux';
import { Provider } from 'react-redux'; 
import rootReducer from './reducers';

const store = createStore(rootReducer);

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>, document.getElementById('root'));

\end{verbatim}


\item Reducer Debug Tip: Instead of internal console.log() statements, use the subscribe() function:

\begin{verbatim}

store.subscribe(() => console.log("store.getState()",store.getState()));

\end{verbatim}

\item Redux Middleware code runs in between the point that an action gets dispatched and the reducers receive the action objects. Think of it as extensions for the redux system; it’s useful for adding new capabilities to the underlying redux logic. One such middleware is redux-thunk.

\item Redux thunk is a library that allows for asynchronous actions to be dispatched. Normally, actions are plain objects. But in the case of using the fetch method, to make an api call, an asynchronous action is useful in order to dispatch different kinds of actions based on the result of the api call.

\item LocalStorage is a JavaScript object that can be used to store items in a key-value structure within the browser.

\item \textbf{Dealing with Cross Origin Resource Sharing:} When making a fetch() request to a remote server, the request will often fail because of the CORS policy. 
\item \textbf{What is CORS?}

\includegraphics[scale=0.22]{cors.png}

This is an internet policy designed to stop applications from making rouge requests to untrusted sources. The policy works as follows: when our local app sends a request to a remote server, our browser / request protocol checks to see if we are listed as an approved connection for the server. If we have an outgoing request, and the external resource has no knowledge of our local app, it is rejected (Same Origin Policy).
\item
\end{itemize}

\section*{Redux Project: Reaction:}
\begin{itemize}
\item For this applicaiton, we will implement the Publisher-Subscriber Architecture for our app, to allow subscribers to a channel to post messages, and reply with Emoji's.
\item Pub/Sub is a pattern that enables communication in a network based on publishing messages to channels, and subscribing to those messages.
\item We will have multiple instances of the application running. Redux Data Flow is structured as follows:

\includegraphics[scale=0.20]{pubsub.png}

\item The steps our application will take, to send a message, are as follows:
\includegraphics[scale=0.20]{pubsublist.png}

\item
\item
\item
\item React context is a way to share data between many components, without having to manually pass objects down through props.

\item
\item
\item
\item The Context Provider Component uses a value property to provide data to any nested component through its context field.

\item
\item
\item The Redux devtools is an extension that allows you to examine the redux store state, and see actions being dispatched in real time.

\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}


\begin{thebibliography}{9}

\bibitem{ganacheSE}
\url{https://ethereum.stackexchange.com/questions/109847/how-to-install-ganache-ui-on-ubuntu-20-04-lts}
\bibitem{}
\url{}
\bibitem{}
\url{}
\bibitem{}
\url{}
\bibitem{}
\url{}
\bibitem{}
\url{}

	
\end{thebibliography}


\end{document}
