\documentclass[8pt,a4paper]{extarticle}
%\documentclass[8pt,twocolumn,a4paper]{extarticle}
%\documentclass[6pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{setspace} 
\usepackage{float}
\usepackage{url}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{multicol}

\pagecolor{black}
\setlist{nolistsep}
\topmargin -2cm
\oddsidemargin -1.5cm
\evensidemargin -1.5cm
\textwidth 18.75cm
\textheight 26cm
\linespread{1.00}
\color{YellowOrange}

%Other Colors: ForestGreen,Cerulean,Salmon,Purple, Red, White

\twocolumn
\title{Title Here}
\author{Author Name Here}

\begin{document}

\newcommand{\mitem}{\item[$\square$]}
\newcommand{\mmitem}{\item[$\triangledown$]}

\maketitle


\section*{First React Application:}

\begin{itemize}
\item To start a React Project, most developers will utilize the create-react-app project template (a node package). Simply install this package and run it to start.
Specifically:

\begin{verse}

npx create-react-app <project name>
mkdir <project name>
npm start

\end{verse}

to install and get the local server running.

\item \textbf{Project Structure:}
\item \textbf{./nodemodules:} All locally installed node dependences are stored here.
\item \textbf{./public:} index.html (front page, robots.txt and favicons stored here.
\item \textbf{./src:} Contains the React Apps (self-contained pieces of interface+code), and support files, including:

- App.js (contains template React App)
- .test files (to run tests later)
- index.js: Where we Insert our App DOM object into the index.html DOM tree (at root).

\item A Most Minimal Example: There are a lot of files in the src folder, but they are not all necessary for react to run. The only necessary file is the index.js file. The following minimial code is needed to insert our content into the index.html DOM tree:

\begin{verbatim}
import React from 'react';
import ReactDOM from "react-dom";
ReactDOM.render(<div>Our React Element </div>, 
document.getElementById("root"));
\end{verbatim}

\item In react, we typically bundle reusable UI elements into \textbf{Components}. 
\item \textbf{Components:} reusable pieces of React code to control part of the user interface. Components capture the structure of UI, and can have internal data to track the user behavior throughout the lifetime of the app.

\item A react app will contain many different \textbf{Components}.
\item Naturally, react has a Component class that can be imported from the react core library.

\begin{verbatim}
import { Component } from 'react';
\end{verbatim}

\item Note that Classes, extended Sub-Classes and object Instances are used heavily in React - so be familiar with OOP.
\item A typical design pattern in React will be to extend template component classes, and add additional fields/methods to implement your application.
\item If you write javascript in the App.js and index.js - console.log() will output directly to a browser inspector.
\item React automatically detects saved changes, and the local server updates. So you can update accordingly.
\item \textbf{State Field:} Subclasses of the Components class have a state field that we can use. We can link an object to this field, to maintain current state as the Component runs.
\item \textbf{State:} dynamic data in a React component. This is often used to track variables that will be re-rendered in the UI based on events that occur in the application.
\item \textbf{React Rule:} Never Directly Modify the State property, if your intention is for changes to occur in the render method based on the updated state values. Use \textit{setState()} instead.
\item \textbf{But Why??} React is \textit{designed to re-render()} a given component when the setState() function is called. If you modify state directly, the changes will \textbf{not} be reflected in browser.
\item \textbf{Props:} Just stands for "Property". Data in a React component that gets passed down from its parent. In the parent component, it will pass data down to the child component through attributes in the child componentâ€™s JSX.
\item Practically, how does the passing work? See the example below:

\begin{verbatim}
class Profile extends Component {
 const {img, link} = this.props.profile

...

}

class SocialProfiles extends Component {
render() {
...
SOCIALPROFILES.map( prof => {
return )
<Profile key={prof.id} profile={prof />
...

}
}
\end{verbatim}

Note that the SOCIALPROFILEs data object gives us our data for this example. We map() on each element of the object.

Here, our Profile class defines a component that is a child to the SocialProfiles Class. We instantiate an object of the Profile class using the <Profile tag>. In the tag, we have placed properties (id, profile) that are fed into the object instance of Profile. We then can access these properties with \textit{this.props(.profile...)}
\item Visual Summary, \textbf{our modified \textit{create-react-app} project:}

\includegraphics[scale=0.25]{appstructure.png}

\end{itemize}



\section*{Breaking Down React: React and Web Development:}

\subsection{}

\subsubsection{}

\begin{itemize}
\item For this section, we will not use the template \textit{create-react-app}, and build a bottom up example.
\item Instead, we will use transpilation and packaging, with a minimal setup, to produce a basic React application.
\item In the end, much of the structure in create-react-app is not necessary to get a minimal example to run.
\item All an app needs is one index.html page, and index.js page.
\item You don't even need to run "npm start" or "node react" - you can use CDNs to load React and ReactDOM libriaries straight into the browser.
\item \textbf{The Minimal Example is as follows:}
\mitem React CDN script tags at the end of index.html
\mitem A div root tag in index.html, so React can insert our <App> into the DOM tree.

In index.js you can just build an app, render() and insert it as normal.
\item JSX: This is short-hand syntactic sugar that is transpiled to code that the browser will understand, when we run our react project (with npm start).
\item Transpilation is typically done with the \textbf{Babel package}.
\item \textbf{Why use Babel?} Javascript compliance is entirely Browser dependent - and JS core language development is completely separate from Browser development. When we want new features that Browsers may not yet support - we can transpile code to cruder JS so that it can be used in current browsers.

\item \textbf{Bundling and Transpiling:} Note that our React project will run in the browser, but ultimately Chrome/FF will not support our import/export system, nor will it support JSX. So we use a \textbf{bundler package (Parcel)} that utilizes Babel to produce a low-level enough JS file so that Chrome/FF can run our app. 
\item Parcel traces our application code, and finds all possible dependences, and then places all imported code into one mega-js file. Any syntactic sugar (such as JSX) is transpiled into lower level JS code that a browsre can understand.

\includegraphics[scale=0.24]{bundle.png}

\item \textbf{Why Use Parcel?} The alternative is to import multiple scripts into the index.html page. These are loaded in order. As our project incrases in size+complexity we may deal with loading issues (namespace clobbering, circular dependencies, etc). To avoid this, Parcel will make one large JS file where dependency/NS issues are alleviated.

\item \textbf{Basic Parcel Usage:}

\begin{verbatim}
parcel <index.html>
\end{verbatim}

It will trace back all code depedencies from here.
 
\item Parcel Folders (in project): These will appear after you run parcel the first time:
\mitem \textbf{.cache}: Stores compiled elements to minimize recompilation later.
\mitem \textbf{dist:} Folder where bundled+transpiled JS code is stored - will rewrite index.html script links to point to this directory!
\item Using Parcel for Dev and Production: Parcel has a hot-wire feature - we can run it with the index.html, and it will auto-update all our code as we develop it.

Parcel however is heavier-weight - we don't use it when we launch produciton code. The following package.json scripts would be seen for a parcel build:

\begin{verbatim}
"scripts": {
    "dev": "parcel src/index.html",
    "build": "parcel build src/index.html",
    "start": "npm run build && live-server dist"
  }
\end{verbatim}

A lighter server (live-server) is chosen to strip down the size of the compiled production build, for launch.

\item \textbf{VirtualDOM:} React has its own stripped-down DOM model, so that it can make dynamic changes to the application page. Note: You don't use native DOM methods (like createElement, getElementById()...) in React - it has its own framework calls to do manipuations.
\item
\item
\item

\end{itemize}

\section{Continued Main React Concepts:}

\subsection{}

\subsubsection{}

\begin{itemize}
\item \textbf{Component Lifecycle:} Components have various event methods, that can be triggered during there operation. In particular, we are interested in when the component starts up, and when it shuts down with two methods:
\item \textbf{componentDidMount():} Called after component is loaded. If the method has to perform setup work or a fetch(), write this code in here.
\item \textbf{ComponentWillUnmount():} Called just before a Component is unmounted and destroyed. Use this as a takedown/cleanup/signalling method.
\item Both methods above are written in the Component extended class - use non-first class functions only. "function" keyword is not required (its a JS class!).
\item \textbf{Stateless Functional Components:} Simplified Notation can be used, if our components contain no state. See Example Below:

\begin{verbatim}

const Project = props => {
	//destructure
  const { title, image, description, link } = props.project;
 
  return (
    <div style={{}}>
      <h3> {title} </h3>
      <img src={image} alt='profile' />
      <p>{description}</p>
      <a href={link}>{link}</a>
    </div>
  )
}
\end{verbatim}

Notice that for static/one-time components, we don't even need the render() method. We can even skip the return and encase the functional body with () - however we did destructuring above, so in this case it cannot be made that simple. Most simple example below:

\begin{verbatim}
const SimpleComp = props => {
	<div>   ~~SOME JSX~~   </div>
}
\end{verbatim}


\item \textbf{fetch():} Default Node/React method for making HTTP calls to external sources. When apps communicate by APIs, HTTP+fetch is typically how it is done.
\item fetch() returns a JS Promise - and is an asyncronous function.
\item \textbf{Fetch Example 1:} Get a JSON object and print it:
\begin{verbatim}
fetch("http://localhost:3005/random_joke")
    .then(response => console.log(response.json()))
    .catch(error => console.log("Error:", error.message));
\end{verbatim}

Will print out json object to console. Basic errors also handled.

\item Example 2: Extract an array of JSON objects from promise, and work with them:

\begin{verbatim}
...
  state = {...jokes: []};

  fetchJokes = () => {
    //Same remainder code, regardless
    fetch("http://localhost:3005/random_ten")
    .then(response => response.json())
    .then(json => this.setState({jokes:json}))

...

 { //At site where we want to print objects...
   this.state.jokes.map(joke => (
   <Joke key={joke.id} joke={joke}/>
    ))
 }
\end{verbatim}

We use the state and setState to pull the jokes array. We can then work on it, avoiding promise/fucntional notation later on down the in the code.

\item \textbf{NOTE (!)} I could not get routing or higher-order functions to work (!!) - course code versions are too old.
\item Applying routing to the application. With react-router, a single page React application can transform into one with multiple pages of different content. Each page matches a url path of the application to a different component.
\item
\item
\item
\item \textbf{Higher-order Components:} A higher-order component is one that takes another component as an input. The idea is to treat the component like a function. Have one component as input, and then output an entirely new component based on that input, with new properties, methods, and/or JSX!
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}

\section{}

\subsection{}

\subsubsection{}

\begin{itemize}
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\item
\end{itemize}


\begin{thebibliography}{9}

\bibitem{ganacheSE}
\url{https://ethereum.stackexchange.com/questions/109847/how-to-install-ganache-ui-on-ubuntu-20-04-lts}
\bibitem{}
\url{}
\bibitem{}
\url{}
\bibitem{}
\url{}
\bibitem{}
\url{}
\bibitem{}
\url{}

	
\end{thebibliography}


\end{document}
